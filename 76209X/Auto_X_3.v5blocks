{"mode":"Blocks","workspace":"<xml xmlns=\"http://www.w3.org/1999/xhtml\"><variables><variable type=\"\" id=\"U`9aA+=)r+L1tzA.)-qi\" islocal=\"false\" iscloud=\"false\" arraylength=\"0\" arraywidth=\"0\">myVariable</variable><variable type=\"\" id=\"}}Ke0MR)jSJDbE}KojeX\" islocal=\"false\" iscloud=\"false\" arraylength=\"0\" arraywidth=\"0\">x1</variable><variable type=\"\" id=\"E,4a^!tlx$l$GTAuADte\" islocal=\"false\" iscloud=\"false\" arraylength=\"0\" arraywidth=\"0\">y1</variable></variables><block type=\"v5_events_when_started\" id=\".NsXwU_L.OuU1l7Sho$F\" x=\"70\" y=\"110\"><next><block type=\"v5_variables_set_variable\" id=\"K6:K-q4[LOc!*L1WimoS\"><field name=\"VARIABLE\" id=\"}}Ke0MR)jSJDbE}KojeX\" variabletype=\"\">x1</field><value name=\"VALUE\"><shadow type=\"math_number\" id=\"rJWe}SZ@XqE-l0R`oe~$\"><field name=\"NUM\">-1400</field></shadow></value><next><block type=\"v5_variables_set_variable\" id=\"Hg;eY=}^WzwpN}GRB!n~\"><field name=\"VARIABLE\" id=\"E,4a^!tlx$l$GTAuADte\" variabletype=\"\">y1</field><value name=\"VALUE\"><shadow type=\"math_number\" id=\"zK7TJ=`(vuuU8[$u_!y~\"><field name=\"NUM\">1320</field></shadow></value><next><block type=\"procedures_call\" id=\"@}G?Tl2wnry[1Jkum5p#\"><mutation proccode=\"goto %n %n x\" proceduredefid=\"70m{R/bI#;7.[~1#t*S)\" argumentids=\"[&quot;?x_4s8pif1gkKpQxme.+&quot;,&quot;entD|.6*a-MP/pspDkwK&quot;]\" warp=\"false\"></mutation><value name=\"?x_4s8pif1gkKpQxme.+\"><shadow type=\"math_number\" id=\"=h;cV^jE::}NYk-.OHX0\"><field name=\"NUM\">1</field></shadow></value><value name=\"entD|.6*a-MP/pspDkwK\"><shadow type=\"math_number\" id=\"[421J5`j~L2-v7@,BLjD\"><field name=\"NUM\">1</field></shadow></value></block></next></block></next></block></next></block><block type=\"procedures_definition\" id=\"@?@9JTI_4Ysm;Er@;__u\" x=\"490\" y=\"110\"><statement name=\"custom_block\"><shadow type=\"procedures_prototype\" id=\"70m{R/bI#;7.[~1#t*S)\"><mutation proccode=\"goto %n %n x\" proceduredefid=\"70m{R/bI#;7.[~1#t*S)\" argumentids=\"[&quot;?x_4s8pif1gkKpQxme.+&quot;,&quot;entD|.6*a-MP/pspDkwK&quot;]\" argumentnames=\"[&quot;0&quot;,&quot;0&quot;]\" argumentdefaults=\"[&quot;todo&quot;,&quot;todo&quot;]\" argumenttypes=\"[&quot;n&quot;,&quot;n&quot;]\" warp=\"false\"></mutation><value name=\"?x_4s8pif1gkKpQxme.+\"><shadow type=\"argument_reporter_number\" id=\"?`p[zm;CE2Uex%KSA7pv\"><mutation funcname=\"goto_0_0_x\" argumentid=\"?x_4s8pif1gkKpQxme.+\" proceduredefid=\"70m{R/bI#;7.[~1#t*S)\"></mutation><field name=\"VALUE\">0</field></shadow></value><value name=\"entD|.6*a-MP/pspDkwK\"><shadow type=\"argument_reporter_number\" id=\"h1(K6ak=AuIT_3c|BK9o\"><mutation funcname=\"goto_0_0_x\" argumentid=\"entD|.6*a-MP/pspDkwK\" proceduredefid=\"70m{R/bI#;7.[~1#t*S)\"></mutation><field name=\"VALUE\">0</field></shadow></value></shadow></statement></block></xml>","rconfig":[{"port":[2,1,1],"name":"Drivetrain","customName":false,"deviceType":"Drivetrain","deviceClass":"smartdrive","setting":{"type":"2-motor","wheelSize":"wheel4in","gear":"ratio18_1","gearRatio":"1:1","direction":"fwd","gyroType":"threewire","width":"295","unit":"mm","wheelbase":"40","wheelbaseUnit":"mm","xOffset":"0","xOffsetUnit":"mm","yOffset":"0","yOffsetUnit":"mm","thetaOffset":"180"},"triportSourcePort":22},{"port":[],"name":"Controller1","customName":false,"deviceType":"Controller","deviceClass":"controller","setting":{"left":"","leftDir":"false","right":"","rightDir":"false","upDown":"","upDownDir":"false","xB":"","xBDir":"false","drive":"tank","id":"primary"}},{"port":[3,4],"name":"MotorGroup3","customName":false,"deviceType":"MotorGroup","deviceClass":"motor_group","setting":{"fwd":"forward","rev":"reverse","gear":"ratio18_1","motor_a_reversed":"false","motor_b_reversed":"true"}}],"slot":2,"platform":"V5","sdkVersion":"20220215.18.00.00","appVersion":"2.3.1","fileFormat":"1.0.1","icon":"","targetBrainGen":"First","cppStatus":"true","cpp":"// Make sure all required headers are included.\n#include <stdio.h>\n#include <stdlib.h>\n#include <stdbool.h>\n#include <math.h>\n#include <string.h>\n\n\n#include \"vex.h\"\n\nusing namespace vex;\n\n// Brain should be defined by default\nbrain Brain;\n\n\n// START V5 MACROS\n#define waitUntil(condition)                                                   \\\n  do {                                                                         \\\n    wait(5, msec);                                                             \\\n  } while (!(condition))\n\n#define repeat(iterations)                                                     \\\n  for (int iterator = 0; iterator < iterations; iterator++)\n// END V5 MACROS\n\n\n// Robot configuration code.\nmotor LeftDriveSmart = motor(PORT2, ratio18_1, false);\nmotor RightDriveSmart = motor(PORT1, ratio18_1, true);\ngyro DrivetrainGyro = gyro(Brain.ThreeWirePort.A);\nsmartdrive Drivetrain = smartdrive(LeftDriveSmart, RightDriveSmart, DrivetrainGyro, 319.19, 320, 40, mm, 1);\n\ncontroller Controller1 = controller(primary);\nmotor MotorGroup3MotorA = motor(PORT3, ratio18_1, false);\nmotor MotorGroup3MotorB = motor(PORT4, ratio18_1, true);\nmotor_group MotorGroup3 = motor_group(MotorGroup3MotorA, MotorGroup3MotorB);\n\n\nvoid calibrateDrivetrain() {\n  wait(200, msec);\n  Brain.Screen.print(\"Calibrating\");\n  Brain.Screen.newLine();\n  Brain.Screen.print(\"Gyro\");\n  DrivetrainGyro.calibrate();\n  while (DrivetrainGyro.isCalibrating()) {\n    wait(25, msec);\n  }\n\n  // Clears the screen and returns the cursor to row 1, column 1.\n  Brain.Screen.clearScreen();\n  Brain.Screen.setCursor(1, 1);\n}\n\n// Generated code.\n\n\n\n\n// define variable for remote controller enable/disable\nbool RemoteControlCodeEnabled = true;\n// define variables used for controlling motors based on controller inputs\nbool DrivetrainLNeedsToBeStopped_Controller1 = true;\nbool DrivetrainRNeedsToBeStopped_Controller1 = true;\n\n// define a task that will handle monitoring inputs from Controller1\nint rc_auto_loop_function_Controller1() {\n  // process the controller input every 20 milliseconds\n  // update the motors based on the input values\n  while(true) {\n    if(RemoteControlCodeEnabled) {\n      // calculate the drivetrain motor velocities from the controller joystick axies\n      // left = Axis3\n      // right = Axis2\n      int drivetrainLeftSideSpeed = Controller1.Axis3.position();\n      int drivetrainRightSideSpeed = Controller1.Axis2.position();\n      \n      // check if the value is inside of the deadband range\n      if (drivetrainLeftSideSpeed < 5 && drivetrainLeftSideSpeed > -5) {\n        // check if the left motor has already been stopped\n        if (DrivetrainLNeedsToBeStopped_Controller1) {\n          // stop the left drive motor\n          LeftDriveSmart.stop();\n          // tell the code that the left motor has been stopped\n          DrivetrainLNeedsToBeStopped_Controller1 = false;\n        }\n      } else {\n        // reset the toggle so that the deadband code knows to stop the left motor nexttime the input is in the deadband range\n        DrivetrainLNeedsToBeStopped_Controller1 = true;\n      }\n      // check if the value is inside of the deadband range\n      if (drivetrainRightSideSpeed < 5 && drivetrainRightSideSpeed > -5) {\n        // check if the right motor has already been stopped\n        if (DrivetrainRNeedsToBeStopped_Controller1) {\n          // stop the right drive motor\n          RightDriveSmart.stop();\n          // tell the code that the right motor has been stopped\n          DrivetrainRNeedsToBeStopped_Controller1 = false;\n        }\n      } else {\n        // reset the toggle so that the deadband code knows to stop the right motor next time the input is in the deadband range\n        DrivetrainRNeedsToBeStopped_Controller1 = true;\n      }\n      \n      // only tell the left drive motor to spin if the values are not in the deadband range\n      if (DrivetrainLNeedsToBeStopped_Controller1) {\n        LeftDriveSmart.setVelocity(drivetrainLeftSideSpeed, percent);\n        LeftDriveSmart.spin(forward);\n      }\n      // only tell the right drive motor to spin if the values are not in the deadband range\n      if (DrivetrainRNeedsToBeStopped_Controller1) {\n        RightDriveSmart.setVelocity(drivetrainRightSideSpeed, percent);\n        RightDriveSmart.spin(forward);\n      }\n    }\n    // wait before repeating the process\n    wait(20, msec);\n  }\n  return 0;\n}\n\n\ntask rc_auto_loop_task_Controller1(rc_auto_loop_function_Controller1);\n// Include the V5 Library\n#include \"vex.h\"\n  \n// Allows for easier use of the VEX Library\nusing namespace vex;\n\n// User defined function\nvoid myblockfunction_goto_0_0_x(double myblockfunction_goto_0_0_x__0, double myblockfunction_goto_0_0_x__0);\n\nfloat myVariable, x1, y1;\n\n// User defined function\nvoid myblockfunction_goto_0_0_x(double myblockfunction_goto_0_0_x__0, double myblockfunction_goto_0_0_x__0) {\n}\n\n// \"when started\" hat block\nint whenStarted1() {\n  x1 = -1400.0;\n  y1 = 1320.0;\n  myblockfunction_goto_0_0_x(1.0, 1.0);\n  return 0;\n}\n\n\nint main() {\n  // Calibrate the Drivetrain\n  calibrateDrivetrain();\n\n  // post event registration\n\n  // set default print color to black\n  printf(\"\\033[30m\");\n\n  // wait for rotation sensor to fully initialize\n  wait(30, msec);\n\n  whenStarted1();\n}","target":"Physical"}